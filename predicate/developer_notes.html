<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Predicate Developer Notes</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
</head>
<body class="article">
<div id="header">
<h1>Predicate Developer Notes</h1>
<span id="author" class="author">Christopher Alfeld</span><br>
<span id="email" class="email"><a href="mailto:calfeld@qualys.com">calfeld@qualys.com</a></span><br>
</div>
<div id="content">
<div class="sect1">
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document is a collection of notes above Predicate with the intended audience of developers of Predicate.</p>
</div>
<div class="paragraph">
<p>The Predicate code is logically divided into three parts: the modules, Core, and Standard.  The modules connect Predicate to IronBee.  Core is the library defining Predicate as a system.  Standard defines a collection of Call nodes that define Predicate as a language.</p>
</div>
<div class="paragraph">
<p>Standard is well described in <a href="reference.html">reference.html</a> and the modules in <a href="modules.html">modules.html</a>.  Core is described below.</p>
</div>
<div class="paragraph">
<p>A small part of Core is used by everything and fundamentally defines what Predicate is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dag</code>: Defines the <code>Node</code> class and its immediate subclasses <code>Call</code> and <code>Literal</code> which form the directed acyclic graphs (DAGs) with are the central data structures of Predicate.</p>
</li>
<li>
<p><code>ironbee</code>: Defines what an <code>EvalContext</code> and an <code>Environment</code> is.  These two types the main points of interaction between Predicate and its client, IronBee.</p>
</li>
<li>
<p><code>value</code>: Defines the <code>Value</code> class, the result of evaluating any Predicate expression.</p>
</li>
<li>
<p><code>eval</code>: Defines the <code>GraphEvalState</code> and <code>NodeEvalState</code> classes which collectively allow for the evaluation of expression trees.</p>
</li>
<li>
<p><code>reporter</code>: Defines the <code>Reporter</code> and <code>NodeReporter</code> classes which form an interface for communicating user caused errors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At the next level are a set of files that provide necessary functionality to any practical Predicate system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>call_factory</code>: Defines the <code>CallFactory</code> classes needed to actually build any non-Literal node.</p>
</li>
<li>
<p><code>merge_graph</code>: Defines the <code>MergeClass</code> class that implements the fundamental common-subexpression-merging algorithm central to Predicate&#8217;s advantage.</p>
</li>
<li>
<p><code>parse</code>: Allows for the conversion of sexpressions to expression trees.</p>
</li>
<li>
<p><code>pre_eval_graph</code>, <code>transform_graph</code>, and <code>validate_graph</code>: Implement parts of the DAG lifecycle.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then there files that support Call development:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>functional</code>: A framework for writing calls.</p>
</li>
<li>
<p><code>meta_call</code>: A predicessor to <code>functional</code> that provides several potential parent classes for calls.</p>
</li>
<li>
<p><code>call_helpers</code>: A place for helper functions; currently very small.</p>
</li>
<li>
<p><code>validate</code>: A variety of helpers for writing validation functions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, there is useful utility code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bfs</code>: Defines code to traverse expression trees.</p>
</li>
<li>
<p><code>dot</code>: Code to output trees and DAGs via GraphViz format, oriented at developers.</p>
</li>
<li>
<p><code>dot2</code>: Code to output trees and DAGs via GraphViz format, oriented at rule writers.</p>
</li>
<li>
<p><code>less</code>: A faster ordering of sexpressions that traditional string comparison.</p>
</li>
<li>
<p><code>tree_copy</code>: Create a copy of an expression tree.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sexpressions">SExpressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SExpressions are a key feature of Predicate.  Their important qualities include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easy to parse, i.e., easy to convert to an expression tree.</p>
</li>
<li>
<p>East to render, i.e., easy to convert from an expression tree.</p>
</li>
<li>
<p>Human readible and editable.</p>
</li>
<li>
<p>Compact (often smaller than the memory used by an equivalent expression tree).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some of the many uses they are put to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Output in introspections and error messages.</p>
</li>
<li>
<p>Parsed as test data.</p>
</li>
<li>
<p>Used to define expression tree equivalence via string equality.</p>
</li>
<li>
<p>Used to duplicate expression trees by rendering and parsing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these uses could be done more directly, without the overhead of parsing, rendering, factories, and string manipulation.  However, their use allows for simple and consistent implementations involving data values easily comprehended developers.  E.g., expression tree cloning could be done via tree traversal without the need for an intermediate string, but by using sexprs, the clone function is a simple function that is almost completely tested by the parsing and rendering tests.  As another example, the use of sexprs in the MergeGraph map eliminates the need for a tree-traversing node comparison function.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adapating_predicate_to_something_other_than_ironbee">Adapating Predicate to something other than IronBee</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Predicate was initially written to be an alternate rule system in IronBee.  It was, however, designed to be as independent as possible.  It directly interacts with IronBee in three ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Value</code> is based on IronBee fields and thus on memory managers and lists.  All of this code is part of the IronBee util library and, as such, independent of most of IronBee.  It could be pulled out and continued to be used, or an alternative runtime type system could be developed to replace it.</p>
</li>
<li>
<p>The evaluation code makes use of the phase concept and reads the phase out of the <code>EvalContext</code>.  Essentially, evaluation defines phase boundaries as places where value/state may change.  In a non-IronBee use, an alternative notion of phase could be used (perhaps a trivial one where value/state never changes).</p>
</li>
<li>
<p>The standard library makes use of IronBee for the phase and ironbee sections.  The former could be adapted according #2 above.  The latter would not make sense in a non-IronBee context.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The file <code>predicate/ironbee.hpp</code> defines <code>EvalContext</code> and <code>Environment</code> as an IronBee transaction and engine, respectively.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_eval_vs_calculate">Eval vs. Calculate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Eval (via <code>GraphEvalState::eval()</code>) is a request that the value of a node be available.  The first time in each phase that an unfinished node is evaled, the value will not be immediately available.  To make the value available, the node is &#8220;calculated&#8221;; specifically the virtual method <code>Node::eval_calculate()</code> is called.  Further evals of the node (until the next phase), will not cause additional calculation.</p>
</div>
<div class="paragraph">
<p>Some nodes will have multiple parents, each of which may eval them before requesting the value.  The logic described above allows the calculation of that value to occur once and the resulting value shared by all parents.</p>
</div>
<div class="paragraph">
<p>The <code>GraphEvalState</code> class separates evaluation (<code>GraphEvalState::eval()</code>) from value/state fetching (<code>GraphEvalState::value()</code> and <code>GraphEvalState::is_finished()</code>).  This has been a source of bugs where the eval is forgotten and as a result the latter provides stale results.  A potential improvement would be to make eval implicit in any request for value or state.  However, this would require callers to have the <code>EvalContext</code> available every the value or state is needed, even in places where it is known that no calculation will be needed.  The Functional framework handles evaluation, removing the burden of remembering from Call developers.</p>
</div>
<div class="sect2">
<h3 id="__code_eval_trace_code"><code>EVAL_TRACE</code></h3>
<div class="paragraph">
<p>At the top of <code>eval.cpp</code> is a commented out define of the <code>EVAL_TRACE</code> symbol.  Uncommenting this causes two cout statements to be inserted in <code>GraphEvalState::eval()</code>.  The first outputs the sexpr of the node at the beginning of every <code>eval()</code>.  The latter outputs the value of the node at the end of every <code>eval()</code>.  These two statements have found to be the most useful for debugging Predicate bugs.  Caveats:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The output does not inform whether a calculation ocurred.</p>
</li>
<li>
<p>If a calculation does occur, there may be recursive calls to <code>eval()</code>.</p>
</li>
<li>
<p>The value calculation calls <code>value()</code> rather than using the local node eval state to handle the case that a calculation caused forwarding.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dag_memory_managerment">DAG Memory Managerment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DAG memory is managed via shared pointers to children and weak pointers to parents.  The user (e.g., <code>MergeGraph</code>) maintains shared pointers to roots.  The roots in turn have shared pointers to children and so forth, providing shared pointer paths to all root descendants.  If the last shared pointer to a root goes away, then the node is destroyed, the shared pointer counts of its children go down, and so forth.  So any part of the DAG unreachable from a root is destroyed.  Meanwhile, the weak pointers provide parent access without interfering with this process.  Code is <code>Node::~Node()</code> ensures that expired weak pointers are removed from parent lists.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traversing_the_dag">Traversing the DAG</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>bfs.hpp</code> provides routines for traversing a DAG either upwards (leaf to root) or downward (root to leaf).  It ensures that each node is visited exactly once.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mergegraph">MergeGraph</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The MergeGraph class it the heart of Predicate.  And it&#8217;s not healthy.</p>
</div>
<div class="paragraph">
<p>The goal of MergeGraph is simple: Allow the construction and manipulation of a DAG while maintaining the invariant that every sexpr/expression-tree in the DAG occurs only once.</p>
</div>
<div class="paragraph">
<p>This goal is easy to achieve during initial construction.  Maintain a set of expressions-trees and when adding a new expression-tree to the DAG, do a downward BFS on it, replacing any subtree with the equivalent subtree from the set, while adding subtrees that do not already appear in the set.  The availability of sexprs make this even easier as a map of string to node pointer can be used.</p>
</div>
<div class="paragraph">
<p>Removal can be similarly handled by traversing the removed subtree and for any node whose parents are all in the removed subtree, removing its entry from the map.</p>
</div>
<div class="paragraph">
<p>But the above explanations are already too simple.  What about external references?  I.e., what if there is a node not in the MergeGraph that has a node in a to-be-removed subtree as a child?  Now there is a parent not in the removed subgraph so the algorithm described above will incorrectly leave the node in the map.  It could be corrected by checking for any parents in the MergeGraph but not in the to-be-removed subtree, but&#8230; it gets complicated.</p>
</div>
<div class="paragraph">
<p>Even so, addition and removal is too poor an API for transformations.  Most actual transformations after construction are replacement of one node with another.  This could be done by removing the node and then adding its replacement, but there are plausible cases where the performance cost would be unacceptably high.  So we want to support a replace node operation as well.  Replacement introduces lots of cases as the part or all of the replacement may already be in the MergeGraph: it might even be a subtree of the subtree to replace.</p>
</div>
<div class="paragraph">
<p>The current implementation works, as far as I know.  But that state was arrived by finding and fixing many bugs through testing and use.  I have little confidence that there are not more bugs lurking.</p>
</div>
<div class="paragraph">
<p>Furthermore, the current implementation only works when used via move semantics.  I.e., when no external references to nodes in the MergeGraph exist.  This is probably a reasonable requirement for the MergeGraph API, but it could be better documented and enforced.</p>
</div>
<div class="paragraph">
<p>What is needed is a careful rethinking of the algorithms, especially the replace node algorithm, and the formulation of internal invariants that guarantee the contract invariant: no distinct nodes rooting identical trees; equivalently, no distinct nodes with the same sexpr.  These invariants should be explicitly stated and the internal subalgorithms written to preserve them.</p>
</div>
<div class="paragraph">
<p>The current MergeGraph implementation is sufficient, but is a likely source of future bugs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional">Functional</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Functional is a framework for writing Call functions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functional is not required.  It is possible, and sometimes necessary, to write Call functions in other ways, e.g., by writing an immediate subclass of <code>Call</code>, or as a subclass of a <code>meta_call</code> class.</p>
</li>
<li>
<p>Functional works best with functions that do not need an <code>EvalContext</code>.  Such functions, by nature, do not care if they are evaluated at configuration or evaluation time, allowing functional to evaluate them at configuration time if possible.</p>
</li>
<li>
<p>Functional works best with primary functions, i.e., those that operate on a single (final) argument using other (earlier; secondary) arguments as configuration.  Functional supports primary functions by automatically evaluating secondary arguments and waiting until all are finished before calling function specific code.</p>
</li>
<li>
<p>Functional works best with functions that can validate each argument in isolation.  I.e., the validity of each argument can be determined without referring to other arguments.  Functional provides easy validation for such functions, including at evaluation time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Functional is named after the C++ concept of a function object and is motivated by the goal of making Predicate call implementation as easy as functional implementation.  In practice, this goal is not reached, but in most cases it is only missed by the requirement of also implementing an argument validation function.</p>
</div>
<div class="paragraph">
<p>Whenever possible, use Functional to implement new calls.  It makes for simpler and more consistent code and automatically provides configuration-time transformations if all arguments can be calculated at configuration time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_evaluation">Evaluation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Predicate currently calculates values using a top-down approach.  That is, a root note is evaluated which may in turn cause children to be evaluated which may in turn cause grand-children to be evaluated and so on.  This approach is simple but faster alternatives exist.</p>
</div>
<div class="paragraph">
<p>The key issue in evaluation strategies is how to represent the dependence of nodes on their children.  The top-down approach gains much of its simplicity from its representation: the dependence is automatically derived by the usage of child values (by calling <code>eval()</code>) in each nodes calculation function.  The usage of a value and the calculation of a value are the same event.  This allows the evaluation framework (<code>eval.cpp</code>) to be minimal&#8201;&#8212;&#8201;handling only memoization&#8201;&#8212;&#8201;while simultaneously imposing no additional benefits on Call writers.</p>
</div>
<div class="paragraph">
<p>An obvious alternative strategy is bottom-up.  In a bottom-up strategy, the key observation is that most non-literal leaves are calls to the <code>var</code> function.  It is possible to, at configuration time, create a list of all leaves that become available at each phase.  E.g., all literal leaves are available at the first phase, and other leaves become available in initial phase of their vars.  Then, at evaluation time, the newly available leaves could be evaluated.  If all the children of a parent have been evaluated, the parent can be evaluated.  Further logic could handle reevaluation of parents iff the child changed value/state (e.g., appended to a list Value).</p>
</div>
<div class="paragraph">
<p>Such a bottom-up strategy could be implemented without too much difficulty.  The evaluation framework would become much more complicated and calls would no longer call <code>eval()</code>.  As calls written using the Functional framework already don&#8217;t handle <code>eval()</code> themselves, removing the calls <code>eval()</code> should be managable.</p>
</div>
<div class="paragraph">
<p>However, the bottom-up strategy so far described is likely worse than the top-down streategy.  In the top-down strategy, there was an implicit notion of unneeded work: a node could decide not to evaluate a child, thus potentially avoiding the cost of evaluating an entire tree.  For example, an <code>or</code> node will only evaluate children until it finds a truthy child; any remaining children will not be evaluated.  To make a superior bottom-up strategy, we need an analogous description of unneeded work.</p>
</div>
<div class="paragraph">
<p>There are only a small number of key functions that can do such pruning, and they are exactly the functions in the Boolean section of the standard library: <code>or</code>, <code>and</code>, <code>if</code> and their relations.  Any intelligent evaluation system must somehow take advantage of these functions ability to ignore some of their children.</p>
</div>
<div class="paragraph">
<p>How to incorporate such parent-child relationships into an evaluation scheme is an open question.  Optimally, we want Predicate to evaluate as few nodes as possible, suggesting a ranking of nodes by number of later evaluations they can potentially eliminate.  That is, we want to know what nodes are optional and evaluate in a way that eliminates optional nodes as early as possible to avoid unnecessary evaluations.</p>
</div>
<div class="paragraph">
<p>Research in machine learning on decision trees is a promising source of ideas.  A search for "decision tree declarative rules" yields a variety of interesting results.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-07-01 13:26:06 CDT
</div>
</div>
</body>
</html>