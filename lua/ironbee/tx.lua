-- =========================================================================
-- Licensed to Qualys, Inc. (QUALYS) under one or more
-- contributor license agreements.  See the NOTICE file distributed with
-- this work for additional information regarding copyright ownership.
-- QUALYS licenses this file to You under the Apache License, Version 2.0
-- (the "License"); you may not use this file except in compliance with
-- the License.  You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- =========================================================================
--
-- LogEvent - A security event generated by IronBee rules.
--
-- Author: Sam Baskinger <sbaskinger@qualys.com>
--
-- =========================================================================

local engine = require('ironbee/engine')
local ffi = require('ffi')
local ironbee = require('ironbee-ffi')
local ibutil = require('ironbee/util')
local ib_logevent = require('ironbee/logevent')

-- Event Type Map used by addEvent.
-- Default values is 'unknown'
local eventTypeMap = {
    observation = ffi.C.IB_LEVENT_TYPE_OBSERVATION,
    alert       = ffi.C.IB_LEVENT_TYPE_ALERT,
    unknown     = ffi.C.IB_LEVENT_TYPE_UNKNOWN
}
setmetatable(eventTypeMap, { __index = ibutil.returnUnknown })

-- Action Map used by addEvent.
-- Default values is 'unknown'
local actionMap = {
    allow   = ffi.C.IB_LEVENT_ACTION_ALLOW,
    block   = ffi.C.IB_LEVENT_ACTION_BLOCK,
    ignore  = ffi.C.IB_LEVENT_ACTION_IGNORE,
    log     = ffi.C.IB_LEVENT_ACTION_LOG,
    unknown = ffi.C.IB_LEVENT_ACTION_UNKNOWN
}
setmetatable(actionMap, { __index = ibutil.returnUnknown })


local _M = {}
_M.__index = _M
_M._COPYRIGHT = "Copyright (C) 2010-2013 Qualys, Inc."
_M._DESCRIPTION = "IronBee Lua Transaction"
_M._VERSION = "1.0"

setmetatable(_M, engine)

_M.new = function(self, ib_engine, ib_tx)
    local o = engine:new(ib_engine)

    -- Store raw C values.
    o.ib_tx = ib_tx

    return setmetatable(o, self)
end

-- Return a list of all the fields currently defined.
_M.getFieldList = function(self)
    local fields = { }

    local ib_list = ffi.new("ib_list_t*[1]")
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)
    ffi.C.ib_list_create(ib_list, tx.mp)
    ffi.C.ib_data_get_all(tx.data, ib_list[0])

    ibutil.each_list_node(ib_list[0], function(field)
        fields[#fields+1] = ffi.string(field.name, field.nlen)
    
        ib_list_node = ffi.C.ib_list_node_next(ib_list_node)
    end)

    return fields 
end

-- Add a string, number, or table to the transaction data.
-- If value is a string or a number, it is appended to the end of the
-- list of values available through the data.
-- If the value is a table, and the table exists in the data,
-- then the values are appended to that table. Otherwise, a new
-- table is created.
_M.add = function(self, name, value)
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)
    if value == nil then
        -- nop.
    elseif type(value) == 'string' then
        ffi.C.ib_data_add_nulstr_ex(tx.data,
                                    ffi.cast("char*", name),
                                    string.len(name),
                                    ffi.cast("char*", value),
                                    nil)
    elseif type(value) == 'number' then
        ffi.C.ib_data_add_num_ex(tx.data,
                                 ffi.cast("char*", name),
                                 #name,
                                 value,
                                 nil)
    elseif type(value) == 'table' then
        local ib_field = ffi.new("ib_field_t*[1]")
        ffi.C.ib_data_get_ex(tx.data,
                             name,
                             string.len(name),
                             ib_field)
        
        -- If there is a value, but it is not a list, make a new table.
        if ib_field[0] == nil or 
           ib_field[0].type ~= ffi.C.IB_FTYPE_LIST then
            ffi.C.ib_data_add_list_ex(tx.data,
                                      ffi.cast("char*", name),
                                      string.len(name),
                                      ib_field)
        end

        for k,v in ipairs(value) do
            self:appendToList(name, v[1], v[2])
        end
    else
        self:logError("Unsupported type %s", type(value))
    end
end

_M.set = function(self, name, value)

    local ib_field = self:getDataField(name)
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)

    if ib_field == nil then
        -- If ib_field == nil, then it doesn't exist and we call add(...).
        -- It is not an error, if value==nil, to pass value to add.
        -- Adding nil is a nop.
        self:add(name, value)
    elseif value == nil then
        -- Delete values when setting a name to nil.
        ffi.C.ib_data_remove_ex(tx.data,
                                ffi.cast("char*", name),
                                #name,
                                nil)
    elseif type(value) == 'string' then
        -- Set a string.
        local nval = ffi.C.ib_mpool_strdup(tx.mp,
                                           ffi.cast("char*", value))
        ffi.C.ib_field_setv(ib_field, nval)
    elseif type(value) == 'number' then
        if value == math.floor(value) then
            -- Set a number.
            local src = ffi.new("ib_num_t[1]", value)
            local dst = ffi.cast("ib_num_t*",
                                ffi.C.ib_mpool_alloc(tx.mp,
                                                    ffi.sizeof("ib_num_t")))
            ffi.copy(dst, src, ffi.sizeof("ib_num_t"))
            ffi.C.ib_field_setv(ib_field, dst)
        else
            -- Set a float number.
            local src = ffi.new("ib_float_t[1]", value)
            local dst = ffi.cast("ib_float_t*",
                                ffi.C.ib_mpool_alloc(tx.mp,
                                                    ffi.sizeof("ib_float_t")))
            ffi.copy(dst, src, ffi.sizeof("ib_float_t"))
            ffi.C.ib_field_setv(ib_field, dst)
        end
    elseif type(value) == 'table' then
        -- Delete a table and add it.
        ffi.C.ib_data_remove_ex(tx.data,
                                ffi.cast("char*", name),
                                #name,
                                nil)
        self:add(name, value)
    else
        self:logError("Unsupported type %s", type(value))
    end
end


-- Get a value from the transaction's data instance.
-- If that parameter points to a string, a string is returned.
-- If name points to a number, a number is returned.
-- If name points to a list of name-value pairs a table is returned
--    where
_M.get = function(self, name)
    local ib_field = self:getDataField(name)
    return self:fieldToLua(ib_field)
end

-- Given a field name, this will return a list of the field names
-- contained in it. If the requested field is a string or an integer, then
-- a single element list containing name is returned.
_M.getNames = function(self, name)
    local ib_field = self:getDataField(name)

    -- To speed things up, we handle a list directly
    if ib_field.type == ffi.C.IB_FTYPE_LIST then
        local t = {}
        local value = ffi.new("ib_list_t*[1]")
        ffi.C.ib_field_value(ib_field, value)
        local ib_list = value[0]

        ibutil.each_list_node(ib_list, function(data)
            t[#t+1] = ffi.string(data.name, data.nlen)
        end)

        return t
    else
        return { ffi.string(ib_field.name, ib_field.nlen) }
    end
end

-- Given a field name, this will return a list of the values that are
-- contained in it. If the requeted field is a string or an integer,
-- then a single element list containing that value is returned.
_M.getValues = function(self, name)
    local ib_field = self:getDataField(name)

    -- To speed things up, we handle a list directly
    if ib_field.type == ffi.C.IB_FTYPE_LIST then
        local t = {}
        local value =  ffi.new("ib_list_t*[1]")
        ffi.C.ib_field_value(ib_field, value)
        local ib_list = value[0]

        ibutil.each_list_node(ib_list, function(data)
            t[#t+1] = self:fieldToLua(data)
        end)

        return t
    else
        return { self:fieldToLua(ib_field) }
    end
end

--
-- Call function func on each event in the current transaction.
--
_M.forEachEvent = function(self, func)
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)
    local list = ffi.new("ib_list_t*[1]")
    ffi.C.ib_logevent_get_all(tx, list)

    ibutil.each_list_node(
        list[0],
        function(event)
            func(ib_logevent:new(event))
        end ,
        "ib_logevent_t*")
end

-- Returns next function, table, and nil.
_M.events = function(self)
    local nextFn = function(t, idx)
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)

        -- Iterate
        if idx == nil then
            local list = ffi.new("ib_list_t*[1]")
            ffi.C.ib_logevent_get_all(tx, list)

            if (list[0] == nil) then
                return nil, nil
            end

            t.i = 0
            t.node = ffi.cast("ib_list_node_t*", ffi.C.ib_list_first(list[0]))
        else
            t.i = idx + 1
            t.node = ffi.C.ib_list_node_next(t.node)
        end

        -- End of list.
        if t.node == nil then
            return nil, nil
        end

        -- Get event and convert it to lua.
        local event = 
            ib_logevent:new(ffi.cast("ib_logevent_t*",
                ffi.C.ib_list_node_data(t.node)))

        -- Return.
        return t.i, event
    end

    return nextFn, {}, nil
end

-- Append a value to the end of the name list. This may be a string
-- or a number. This is used by ib_obj.add to append to a list.
_M.appendToList = function(self, listName, fieldName, fieldValue)

    local field = ffi.new("ib_field_t*[1]")
    local tx = ffi.cast("ib_tx_t *", self.ib_tx)

    if type(fieldValue) == 'string' then
        -- Create the field
        ffi.C.ib_field_create(field,
                                 tx.mp,
                                 ffi.cast("char*", fieldName),
                                 #fieldName,
                                 ffi.C.IB_FTYPE_NULSTR,
                                 ffi.cast("char*", fieldValue))

    elseif type(fieldValue) == 'number' then
        if fieldValue == math.floor(fieldValue) then
            local fieldValue_p = ffi.new("ib_num_t[1]", fieldValue)

            ffi.C.ib_field_create(field,
                                  tx.mp,
                                  ffi.cast("char*", fieldName),
                                  #fieldName,
                                  ffi.C.IB_FTYPE_NUM,
                                  fieldValue_p)
        else
            local fieldValue_p = ffi.new("ib_float_t[1]", fieldValue)

            ffi.C.ib_field_create(field,
                                  tx.mp,
                                  ffi.cast("char*", fieldName),
                                  #fieldName,
                                  ffi.C.IB_FTYPE_FLOAT,
                                  fieldValue_p)
        end
    else
        return
    end

    -- Fetch the list
    local list = self:getDataField(listName)

    -- Append the field
    ffi.C.ib_field_list_add(list, field[0])
end

-- Add an event. 
-- The msg argument is typically a string that is the message to log,
-- followed by a table of options.
--
-- If msg is a table, however, then options is ignored and instead
-- msg is processed as if it were the options argument. Think of this
-- as the argument msg being optional.
--
-- If msg is omitted, then options should contain a key 'msg' that
-- is the message to log.
--
-- The options argument should also specify the following (or they will
-- default to UNKNOWN):
--
-- recommended_action - The recommended action.
--     - block
--     - ignore
--     - log
--     - unknown (default)
-- action - The action to take. Values are the same as recommended_action.
-- type - The rule type that was matched.
--     - observation
--     - unknown (default)
-- confidence - An integer. The default is 0.
-- severity - An integer. The default is 0.
-- msg - If msg is not given, then this should be the alert message.
-- tags - List (table) of tag strings: { 'tag1', 'tag2', ... }
-- fields - List (table) of field name strings: { 'ARGS', ... }
--
_M.addEvent = function(self, msg, options)

    local message

    -- If msg is a table, then options are ignored.
    if type(msg) == 'table' then
        options = msg
        message = ffi.cast("char*", msg['msg'] or '-')
    else
        message = ffi.cast("char*", msg)
    end

    if options == nil then
        options = {}
    end

    local event = ffi.new("ib_logevent_t*[1]")
    local rulename = ffi.cast("char*", options['rulename'] or 'anonymous')

    -- Map options
    local rec_action      = actionMap[options.recommended_action]
    local event_type      = eventTypeMap[options.type]
    local confidence      = options.confidence or 0
    local severity        = options.severity or 0

    local tx = ffi.cast("ib_tx_t *", self.ib_tx)
    
    ffi.C.ib_logevent_create(event,
                             tx.mp,
                             rulename,
                             event_type,
                             rec_action,
                             confidence,
                             severity,
                             message
                            )

    -- Add tags
    if options.tags ~= nil then
        if type(options.tags) == 'table' then
            for k,v in ipairs(options.tags) do
                ffi.C.ib_logevent_tag_add(event[0], v)
            end
        end
    end

    -- Add field names
    if options.fields ~= nil then
        if type(options.fields) == 'table' then
            for k,v in ipairs(options.fields) do
                ffi.C.ib_logevent_field_add(event[0], v)
            end
        end
    end

    ffi.C.ib_logevent_add(tx, event[0])
end

-- Return a ib_field_t* to the field named and stored in the DPI.
-- This is used to quickly pull named fields for setting or getting values.
_M.getDataField = function(self, name)
    local ib_field = ffi.new("ib_field_t*[1]")

    local tx = ffi.cast("ib_tx_t *", self.ib_tx)

    ffi.C.ib_data_get_ex(tx.data,
                         name,
                         string.len(name),
                         ib_field)
    return ib_field[0]
end

-- ###########################################################################


return _M
